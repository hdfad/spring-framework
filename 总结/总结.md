# bean的创建过程

## 预实例化bean
refresh\
finishBeanFactoryInitialization\
beanFactory.preInstantiateSingletons()\
getMergedLocalBeanDefinition -> rootBD\
单例非懒加载的bean\
普通bean\
getBean(beanName)\
doGetBean(name, null, null, false);\
getSingleton(beanName)   isSingletonCurrentlyInCreation：bean是否正在创建中 三级缓存 return null\
getParentBeanFactory()  递归 todo\
RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\
checkMergedBeanDefinition(mbd, beanName, args); 检查合并后的BeanDefinition不允许抽象类的BeanDefinition\
mbd.getDependsOn(); 存在@DependsOn或者xml定义depends-on的的标签
- registerDependentBean
- getBean(dep)
## 实例化bean
### getSingleton
sharedInstance = getSingleton(beanName,()->{
    return createBean(beanName, mbd, args);
})
### createBean
**非spring Bean**\
Object bean = resolveBeforeInstantiation(beanName, mbdToUse); \
- 非spring管理的bean的创建过程交给spring,
- 由InstantiationAwareBeanPostProcessor负责bean的实例化-->InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation
- 由BeanPostProcessor负责bean的初始化--> postProcessAfterInitialization
- 这部分bean返回后不再参与doCreateBean过程
- 为什么spring是在初始化之后proxy而不是resolveBeforeInstantiation?
 
**spring Bean**\
Object beanInstance = doCreateBean(beanName, mbdToUse, args);

### doCreateBean
createBeanInstance 获取bean对象
- Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); 解析LookUp，解析合适的构造函数，见代码注释
- autowireConstructor dcfbp返回非null的构造函数进行注入 将注入对象封装成BeanWrapper返回
- instantiateBean(beanName, mbd); 当不存在合适的构造函数时，就通过反射获取对象，封装成BeanWrapper

### 循环依赖条件判断
boolean earlySingletonExposure  ->true  addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
- 如果允许循环依赖，则提前暴露bean到singletonFactories三级缓存中

### populateBean
InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation
- bean实例化后对bean进行属性填充时进行调用，当返回false时不会populateBean
- 在需要对bean自定义属性填充时可在此处完善bean填充信息然后返回false或者添加bean的支持后继续进行属性填充

AutowiredMode 注入模型
对没有实现@Autowired、 @Resource注解的情况下，对Bean实例进行注入的集中方式




#流程图
![图片](../总结/image/getBean.png)